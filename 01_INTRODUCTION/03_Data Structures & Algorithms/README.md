# 1.3) Data Structures & Algorithms

Data Structures are the programmatic way of storing data so that data can be used efficiently.

<details open>
<summary>Table of Contents</summary>
<br>

[Data Definition](#h1)

[Data Object](#h2)

[Data Type](#h3)

[Built-in Data Type](#h4)

[Derived Data Type](#h5)

[Basic Operations](#h6)

[Algorithms](#h7)

[Asymptotic Analysis](#h8)

[Greedy Algorithms](#h9)

[Divide and Conquer](#h10)

[Dynamic Programming](#h11)

[USEFULL LINKS](#h12)

</details>

<a name="h1"/>

### Data Structures

**Data Definition:**

Data Definition defines a particular data with the following characteristics:

- **Atomic:** Definition should define a single concept.

- **Traceable:** Definition should be able to be mapped to some data element.

- **Accurate:** Definition should be unambiguous.

- **Clear and Concise:** Definition should be understandable.

<a name="h2"/>

**Data Object:**

Data Object represents an object having a data.

<a name="h3"/>

**Data Type:**

Data type is a way to classify various types of data such as integer, string, etc. which determines the values that can be used with the corresponding type of data, the type of operations that can be performed on the corresponding type of data. There are two data types:

* Built-in Data Type
* Derived Data Type

<a name="h4"/>

**Built-in Data Type:**

Those data types for which a language has built-in support are known as Built-in Data types. For example, most of the languages provide the following built-in data types.

* Integers
* Boolean (true, false)
* Floating (Decimal numbers)
* Character and Strings

<a name="h5"/>

**Derived Data Type:**

Those data types which are implementation independent as they can be implemented in one or the other way are known as derived data types. These data types are normally built by the combination of primary or built-in data types and associated operations on them. For example:

* List
* Array
* Stack
* Queue

<a name="h6"/>

**Basic Operations:**

The data in the data structures are processed by certain operations. The particular data structure chosen largely depends on the frequency of the operation that needs to be performed on the data structure:

* Traversing
* Searching
* Insertion
* Deletion
* Sorting
* Merging

<a name="h7"/>

### Algorithms

Algorithm is a step-by-step procedure, which defines a set of instructions to be executed in a certain order to get the desired output.

Important categories of algorithms from the data structure point of view:

- **Search:** Algorithm to search an item in a data structure.

- **Sort:** Algorithm to sort items in a certain order.

- **Insert:** Algorithm to insert item in a data structure.

- **Update:** Algorithm to update an existing item in a data structure.

- **Delete:** Algorithm to delete an existing item from a data structure.

Some algorithm terminology on data structure point of view:

<a name="h8"/>

**Asymptotic Analysis:**

Asymptotic analysis of an algorithm refers to defining the mathematical boundation/framing of its run-time performance. Using asymptotic analysis, we can very well conclude the best case, average case, and worst case scenario of an algorithm.

<a name="h9"/>

**Greedy Algorithms:**

An algorithm is designed to achieve optimum solution for a given problem. In greedy algorithm approach, decisions are made from the given solution domain. As being greedy, the closest solution that seems to provide an optimum solution is chosen. Greedy algorithms try to find a localized optimum solution, which may eventually lead to globally optimized solutions. However, generally greedy algorithms do not provide globally optimized solutions.

<a name="h10"/>

**Divide and Conquer:**

In divide and conquer approach, the problem in hand, is divided into smaller sub-problems and then each problem is solved independently. When we keep on dividing the subproblems into even smaller sub-problems, we may eventually reach a stage where no more division is possible. Those "atomic" smallest possible sub-problem (fractions) are solved. The solution of all sub-problems is finally merged in order to obtain the solution of an original problem.

<a name="h11"/>

**Dynamic Programming:**

Dynamic programming approach is similar to divide and conquer in breaking down the problem into smaller and yet smaller possible sub-problems. But unlike, divide and conquer, these sub-problems are not solved independently. Rather, results of these smaller sub-problems are remembered and used for similar or overlapping sub-problems. Dynamic programming is used where we have problems, which can be divided into similar sub-problems, so that their results can be re-used. Mostly, these algorithms are used for optimization. Before solving the in-hand sub-problem, dynamic algorithm will try to examine the results of the previously solved sub-problems. The solutions of sub-problems are combined in order to achieve the best solution.

<a name="h12"/>

**USEFULL LINKS**

**Data Structures Basics**

https://www.tutorialspoint.com/data_structures_algorithms/data_structures_basics.htm

**Algorithms Basics**

https://www.tutorialspoint.com/data_structures_algorithms/algorithms_basics.htm

**Local MinGW Environment Setup for tests:**

https://www.tutorialspoint.com/data_structures_algorithms/data_structure_environment.htm

**MinGW basic commands:**

http://www.mingw.org/wiki/MinGW_for_First_Time_Users_HOWTO

**Data Structures overview:**

https://www.tutorialspoint.com/data_structures_algorithms/data_structure_overview.htm



